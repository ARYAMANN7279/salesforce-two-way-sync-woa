/* eslint-disable import/first */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    GSActor: function() {
        return _interfaces.GSActor;
    },
    GSCachingDataSource: function() {
        return _sources.GSCachingDataSource;
    },
    GSCloudEvent: function() {
        return _interfaces.GSCloudEvent;
    },
    GSContext: function() {
        return _interfaces.GSContext;
    },
    GSDataSource: function() {
        return _sources.GSDataSource;
    },
    GSDataSourceAsEventSource: function() {
        return _sources.GSDataSourceAsEventSource;
    },
    GSEventSource: function() {
        return _sources.GSEventSource;
    },
    GSResponse: function() {
        return _interfaces.GSResponse;
    },
    GSStatus: function() {
        return _interfaces.GSStatus;
    },
    PlainObject: function() {
        return _types.PlainObject;
    },
    RedisOptions: function() {
        return _sources.RedisOptions;
    },
    default: function() {
        return _default;
    },
    generateSwaggerJSON: function() {
        return _swagger.generateSwaggerJSON;
    },
    logger: function() {
        return _logger.logger;
    },
    yamlLoader: function() {
        return _yamlLoader.default;
    }
});
require("dotenv/config");
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _logger = require("./logger");
const _path = require("path");
const _process = require("process");
const _swaggeruiexpress = /*#__PURE__*/ _interop_require_default(require("swagger-ui-express"));
const _metrics = /*#__PURE__*/ _interop_require_default(require("@godspeedsystems/metrics"));
const _definitionsLoader = /*#__PURE__*/ _interop_require_default(require("./core/definitionsLoader"));
const _datasourceLoader = /*#__PURE__*/ _interop_require_default(require("./core/datasourceLoader"));
const _eventsourceLoader = /*#__PURE__*/ _interop_require_default(require("./core/eventsourceLoader"));
const _functionLoader = /*#__PURE__*/ _interop_require_default(require("./core/functionLoader"));
const _eventLoader = /*#__PURE__*/ _interop_require_default(require("./core/eventLoader"));
const _mappingLoader = /*#__PURE__*/ _interop_require_default(require("./core/mappingLoader"));
const _interfaces = require("./core/interfaces");
const _sources = require("./core/_interfaces/sources");
const _types = require("./types");
const _jsonSchemaValidation = require("./core/jsonSchemaValidation");
const _swagger = require("./router/swagger");
const _utils = require("./core/utils");
const _codeLoader = /*#__PURE__*/ _interop_require_default(require("./core/codeLoader"));
const _scriptRuntime = require("./core/scriptRuntime");
const _yamlLoader = /*#__PURE__*/ _interop_require_default(require("./core/yamlLoader"));
function _async_iterator(iterable) {
    var method, async, sync, retry = 2;
    for("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;){
        if (async && null != (method = iterable[async])) return method.call(iterable);
        if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));
        async = "@@asyncIterator", sync = "@@iterator";
    }
    throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(s) {
    function AsyncFromSyncIteratorContinuation(r) {
        if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
        var done = r.done;
        return Promise.resolve(r.value).then(function(value) {
            return {
                value: value,
                done: done
            };
        });
    }
    return AsyncFromSyncIterator = function(s) {
        this.s = s, this.n = s.next;
    }, AsyncFromSyncIterator.prototype = {
        s: null,
        n: null,
        next: function() {
            return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
        },
        return: function(value) {
            var ret = this.s.return;
            return void 0 === ret ? Promise.resolve({
                value: value,
                done: !0
            }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
        },
        throw: function(value) {
            var thr = this.s.return;
            return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
        }
    }, new AsyncFromSyncIterator(s);
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
var config = require('config');
class Godspeed {
    initialize() {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._loadDefinitions().then(function() {
                var _ref = _async_to_generator(function*(definitions) {
                    _this.definitions = definitions;
                    _this.mappings = yield _this._loadMappings();
                    //@ts-ignore
                    global.mappings = _this.mappings;
                    let datasources = yield _this._loadDatasources();
                    _this.datasources = datasources;
                    //@ts-ignore
                    global.datasources = datasources;
                    _this.plugins = yield _this._loadPlugins();
                    //@ts-ignore
                    global.plugins = _this.plugins;
                    let fnLoadResponse = yield _this._loadFunctions();
                    _this.workflows = fnLoadResponse.functions;
                    //@ts-ignore
                    global.workflows = _this.workflows;
                    //@ts-ignore
                    global.functions = _this.workflows;
                    _this.nativeFunctions = fnLoadResponse.nativeFunctions;
                    if (!_this.withoutEventSource) {
                        let eventsources = yield _this._loadEventsources();
                        _this.eventsources = eventsources;
                        //@ts-ignore
                        global.eventsources = eventsources;
                        let events = yield _this._loadEvents();
                        _this.events = events;
                        yield _this.subscribeToEvents();
                        let status = Object.keys(eventsources).map((esName)=>{
                            let es = eventsources[esName];
                            return `${es.config.type}: ${es.config.port}`;
                        }).join(' ');
                        _logger.logger.info(`[${_this.isProd ? 'Production' : 'Dev'} Server][Running] ('${status.split(' ')[0]}' event source, '${status.split(' ')[1]}' port).`);
                    }
                });
                return function(definitions) {
                    return _ref.apply(this, arguments);
                };
            }()).catch((error)=>{
                _logger.logger.error('pm_logger %o %s %o', error, error.message, error.stack);
            });
        })();
    }
    _loadMappings() {
        var _this = this;
        return _async_to_generator(function*() {
            _logger.logger.info('[START] Load mappings from %s', _this.folderPaths.mappings);
            let mappings = (0, _mappingLoader.default)(_this.folderPaths.mappings);
            // logger.debug('Mappings %o', mappings);
            _logger.logger.info('[END] Load mappings');
            return mappings;
        })();
    }
    _loadEvents() {
        var _this = this;
        return _async_to_generator(function*() {
            _logger.logger.info('[START] Load events from %s', _this.folderPaths.events);
            let events = yield (0, _eventLoader.default)(_this.workflows, _this.nativeFunctions, _this.folderPaths.events, _this.eventsources);
            // logger.debug('Events %o', events);
            // logger.debug('[END] Loaded events %o', Object.keys(events));
            _logger.logger.debug('[END] Loaded all events');
            return events;
        })();
    }
    _loadDefinitions() {
        var _this = this;
        return _async_to_generator(function*() {
            _logger.logger.info('[START] Load definitions from %s', _this.folderPaths.definitions);
            const definitions = yield (0, _definitionsLoader.default)(_this.folderPaths.definitions);
            // logger.debug('Definitions %o', definitions);
            _logger.logger.info('[END] Load definitions');
            return definitions;
        })();
    }
    _loadFunctions() {
        var _this = this;
        return _async_to_generator(function*() {
            _logger.logger.info('[START] Load functions from %s', _this.folderPaths.workflows);
            try {
                const loadFnStatus = yield (0, _functionLoader.default)(_this.datasources, _this.folderPaths.workflows);
                if (loadFnStatus.success) {
                    _logger.logger.info('[END] Load functions');
                    return loadFnStatus;
                } else {
                    _logger.logger.fatal('Error in loading project functions %o', loadFnStatus);
                    process.exit(1);
                }
            } catch (err) {
                _logger.logger.fatal('Error in loading project functions %s %o', err.message, err.stack);
                process.exit(1);
            }
        // logger.debug('Functions %o', Object.keys(loadFnStatus.functions));
        })();
    }
    _loadPlugins() {
        var _this = this;
        return _async_to_generator(function*() {
            _logger.logger.info('[START] Load plugins from %s', _this.folderPaths.plugins);
            const modules = yield (0, _codeLoader.default)(_this.folderPaths.plugins);
            (0, _scriptRuntime.importAll)(modules, global);
            _logger.logger.debug('Plugins loaded %o', Object.keys(modules));
            return modules;
        })();
    }
    _loadDatasources() {
        var _this = this;
        return _async_to_generator(function*() {
            _logger.logger.info('[START] Load data sources from %s', _this.folderPaths.datasources);
            let datasources = yield (0, _datasourceLoader.default)(_this.folderPaths.datasources);
            //logger.debug('data sources %o', datasources);
            _logger.logger.info('[END] Load data sources');
            return datasources;
        })();
    }
    _loadEventsources() {
        var _this = this;
        return _async_to_generator(function*() {
            _logger.logger.info('[START] Load event sources from %s', _this.folderPaths.eventsources);
            let eventsources = yield (0, _eventsourceLoader.default)(_this.folderPaths.eventsources, _this.datasources);
            _logger.logger.debug('event sources loaded %o', Object.keys(eventsources));
            _logger.logger.info('[END] event sources.');
            return eventsources;
        })();
    }
    subscribeToEvents() {
        var _this = this;
        return _async_to_generator(function*() {
            var _httpEventSource_config;
            const httpEvents = {};
            {
                var _iteratorAbruptCompletion = false, _didIteratorError = false, _iteratorError;
                try {
                    for(var _iterator = _async_iterator(Object.keys(_this.events)), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false){
                        let _value = _step.value;
                        const route = _value;
                        let eventKey = route;
                        let eventSourceName = route.split('.')[0];
                        const eventSource = _this.eventsources[eventSourceName];
                        // for swagger UI
                        if (eventSourceName === 'http') {
                            httpEvents[eventKey] = _object_spread({}, _this.events[eventKey]);
                        }
                        const processEventHandler = yield _this.processEvent(_this, route);
                        yield eventSource.subscribeToEvent(route, _this.events[eventKey], processEventHandler, _object_spread({}, _this.events[route]));
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (_iteratorAbruptCompletion && _iterator.return != null) {
                            yield _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            const httpEventSource = _this.eventsources['http']; // eslint-disable-line
            if (httpEventSource === null || httpEventSource === void 0 ? void 0 : (_httpEventSource_config = httpEventSource.config) === null || _httpEventSource_config === void 0 ? void 0 : _httpEventSource_config.docs) {
                //@ts-ignore
                const httpEventsSwagger = (0, _swagger.generateSwaggerJSON)(httpEvents, _this.definitions, httpEventSource.config);
                // @ts-ignore
                httpEventSource.client.use(httpEventSource.config.docs.endpoint || '/api-docs', _swaggeruiexpress.default.serve, _swaggeruiexpress.default.setup(httpEventsSwagger));
                _this.saveHttpEventsSwaggerJson(httpEventsSwagger);
            }
            if (process.env.OTEL_ENABLED == 'true') {
                // @ts-ignore
                httpEventSource.client.get('/metrics', function() {
                    var _ref = _async_to_generator(function*(req, res) {
                        let prismaMetrics = '';
                        for(let ds in _this.datasources){
                            var _this_datasources_ds_client__previewFeatures, _this_datasources_ds_client;
                            if ((_this_datasources_ds_client = _this.datasources[ds].client) === null || _this_datasources_ds_client === void 0 ? void 0 : (_this_datasources_ds_client__previewFeatures = _this_datasources_ds_client._previewFeatures) === null || _this_datasources_ds_client__previewFeatures === void 0 ? void 0 : _this_datasources_ds_client__previewFeatures.includes("metrics")) {
                                // @ts-ignore
                                prismaMetrics += yield _this.datasources[ds].client.$metrics.prometheus({
                                    globalLabels: {
                                        server: process.env.HOSTNAME,
                                        datasource: `${ds}`
                                    }
                                });
                            }
                        }
                        let appMetrics = yield _metrics.default.register.metrics();
                        res.end(appMetrics + prismaMetrics);
                    });
                    return function(req, res) {
                        return _ref.apply(this, arguments);
                    };
                }());
            }
        })();
    }
    saveHttpEventsSwaggerJson(swaggerJson) {
        var _swaggerJson_info;
        const swaggerDir = process.cwd() + '/docs/';
        _fs.default.mkdirSync(swaggerDir, {
            recursive: true
        });
        const swaggerFileName = ((_swaggerJson_info = swaggerJson.info) === null || _swaggerJson_info === void 0 ? void 0 : _swaggerJson_info.title) || 'http';
        _fs.default.writeFileSync(swaggerDir + swaggerFileName + '-swagger.json', JSON.stringify(swaggerJson), 'utf-8');
    }
    /**
   * For executing a workflow directly without an eventsource from a Nodejs project
   */ executeWorkflow(name, args) {
        var _this = this;
        return _async_to_generator(function*() {
            const event = new _interfaces.GSCloudEvent('id', "", new Date(), 'http', '1.0', args, 'REST', new _interfaces.GSActor('user'), {});
            const childLogger = _logger.logger.child(_this.getCommonAttrs(event));
            const ctx = new _interfaces.GSContext(_this.config, _this.datasources, event, _this.mappings, _this.nativeFunctions, _this.plugins, _logger.logger, childLogger);
            const workflow = _this.workflows[name];
            if (!workflow) {
                childLogger.error('workflow not found %s', name);
            }
            const res = yield workflow(ctx, args);
            return res;
        })();
    }
    processEvent(local, route) {
        var _this = this;
        return _async_to_generator(function*() {
            const { workflows, datasources, mappings } = local;
            const eventSourceName = route.split('.')[0];
            return function() {
                var _ref = _async_to_generator(function*(event, eventConfig) {
                    const childLogger = _logger.logger.child(_this.getLogAttributes(event, eventConfig, eventSourceName));
                    // TODO: lot's of logging related steps
                    childLogger.debug('processing event %s', event.type);
                    // TODO: Once the config loader is sorted, fetch the apiVersion from config
                    let eventHandlerWorkflow;
                    let validateStatus;
                    try {
                        validateStatus = (0, _jsonSchemaValidation.validateRequestSchema)(event.type, event, eventConfig);
                    } catch (err) {
                        const { headers, body, query, params } = event.data;
                        const eventInput = {
                            headers,
                            query,
                            body,
                            params
                        };
                        childLogger.error('Validation of event request data had an unexpected error. Perhaps something wrong with your schema def? \n Event route %s \n event input %o \n error message %s error stack', route, eventInput, err.message);
                        return new _interfaces.GSStatus(false, 500, undefined, //`Error in validating request for the event ${event.type} and request data is \n %o`, eventInput,
                        {
                            error: {
                                message: err.message
                            }
                        });
                    }
                    let eventSpec = eventConfig;
                    if (validateStatus.success === false) {
                        // If `on_request_validation_error` is defined in the event, let's execute that
                        // Else return with validation error
                        if (eventSpec.on_request_validation_error) {
                            const validationError = {
                                success: false,
                                code: validateStatus.code,
                                message: 'request validation failed.',
                                error: validateStatus.message,
                                data: validateStatus.data
                            };
                            childLogger.error('Validation of event request failed %s. Will run validation error handler', JSON.stringify(validationError));
                            // event.data = { event: event.data, validationError };
                            event.data.validation_error = validationError;
                            // A workflow is always a series execution of its tasks. ie., a GSSeriesFunction
                            eventHandlerWorkflow = eventSpec.on_request_validation_error;
                        } else {
                            childLogger.error('Validation of event request failed %s. Returning.', JSON.stringify(validateStatus));
                            return validateStatus;
                        }
                    } else {
                        childLogger.debug('Request JSON Schema validated successfully. Route %s', route);
                        eventHandlerWorkflow = workflows[eventSpec.fn];
                    }
                    const ctx = new _interfaces.GSContext(config, datasources, event, mappings, workflows, {}, _logger.logger, childLogger);
                    //Now check authorization, provided request validation has succeeded
                    if (eventConfig.authz && validateStatus.success) {
                        //If authorization workflow fails, we return with its status right away.
                        ctx.forAuth = true;
                        const authzStatus = yield eventConfig.authz(ctx);
                        ctx.forAuth = false;
                        if (authzStatus.code === 403 || authzStatus.success !== true) {
                            var _authzStatus_data;
                            //Authorization task executed successfully and returned user is not authorized
                            authzStatus.success = false;
                            // If status code is not set or is not in the range of 400-600 then set the code to 403
                            //error status codes in http should be between 400-599
                            if (!authzStatus.code || authzStatus.code < 400 || authzStatus.code > 599) {
                                authzStatus.code = 403;
                            }
                            childLogger.debug(`Authorization task failed at the event level with code ${authzStatus.code}`);
                            if (!((_authzStatus_data = authzStatus.data) === null || _authzStatus_data === void 0 ? void 0 : _authzStatus_data.message)) {
                                (0, _utils.setAtPath)(authzStatus, 'data.message', authzStatus.message || 'Access Forbidden');
                            }
                            return authzStatus;
                        } else {
                            //since authz was successful
                            //in case com.gs.return was used, the exitWithStatus would be there
                            //because com.gs.return sets exitWithStatus: true for every call
                            //Remove exitWithStatus otherwise it will be taken as error in 
                            //interfaces.ts when the event handler will be called
                            delete ctx.exitWithStatus;
                        }
                    //Autorization is passed. Proceeding.
                    // childLogger.debug('Authorization passed at the event level');
                    }
                    let eventHandlerStatus;
                    try {
                        const eventHandlerResponse = yield eventHandlerWorkflow(ctx);
                        // The final status of the handler workflow is calculated from the last task of the handler workflow (series function)
                        eventHandlerStatus = eventHandlerResponse; //ctx.outputs[eventHandlerWorkflow.id] || eventHandlerResponse;
                        if (typeof eventHandlerStatus !== 'object' || !('success' in eventHandlerStatus)) {
                            //Assume workflow has returned just the data and has executed sucessfully
                            eventHandlerStatus = new _interfaces.GSStatus(true, 200, undefined, eventHandlerResponse);
                        }
                        if (!eventHandlerStatus.success) {
                            childLogger.error('Event handler for %s returned \n with status %o \n for inputs \n params %o \n query %o \n body %o \n headers %o', route, eventHandlerStatus, ctx.inputs.data.params, ctx.inputs.data.query, ctx.inputs.data.body, ctx.inputs.data.headers);
                        } else {
                            childLogger.debug('Event handler for %s returned with status %o', route, eventHandlerStatus);
                        }
                        // event workflow executed successfully
                        // lets validate the response schema
                        let validateResponseStatus = (0, _jsonSchemaValidation.validateResponseSchema)(event.type, eventHandlerStatus);
                        if (validateResponseStatus.success) {
                            return eventHandlerStatus;
                        } else {
                            if (!eventSpec.on_response_validation_error) {
                                childLogger.error('Validation of event response failed %o', validateResponseStatus.data);
                                return new _interfaces.GSStatus(false, 500, 'response validation error', validateResponseStatus.data);
                            } else {
                                const validationError = {
                                    success: false,
                                    code: validateResponseStatus.code,
                                    message: 'response validation failed.',
                                    error: validateResponseStatus.message,
                                    data: validateResponseStatus.data
                                };
                                childLogger.error('Validation of event response failed %s', JSON.stringify(validationError));
                                // event.data = { event: event.data, validationError };
                                event.data.validation_error = validationError;
                                // A workflow is always a series execution of its tasks. ie., a GSSeriesFunction
                                return yield eventSpec.on_response_validation_error(ctx);
                            }
                        }
                    } catch (error) {
                        childLogger.error(`Error occured in event handler execution for event ${eventConfig.key}. Error: ${error}`);
                        return new _interfaces.GSStatus(false, 500, `Error in executing handler ${eventSpec.fn} for the event ${event.type} `, {
                            error,
                            message: error.message
                        });
                    }
                });
                return function(event, eventConfig) {
                    return _ref.apply(this, arguments);
                };
            }();
        })();
    }
    /**
   * 
   * @param event 
   * @param eventConfig 
   * @returns All the log attributes specific to this event
   */ getLogAttributes(event, eventConfig, eventSourceName) {
        var _this_eventsources_eventSourceName_config_log, _this_eventsources_eventSourceName_config, _eventConfig_log;
        const attrs = this.getCommonAttrs(event);
        attrs.event = event.type;
        attrs.workflow_name = eventConfig.fn;
        // Now override common log.attributes/log_attributes with event source level attributes
        const eventSrcAttrs = (_this_eventsources_eventSourceName_config = this.eventsources[eventSourceName].config) === null || _this_eventsources_eventSourceName_config === void 0 ? void 0 : (_this_eventsources_eventSourceName_config_log = _this_eventsources_eventSourceName_config.log) === null || _this_eventsources_eventSourceName_config_log === void 0 ? void 0 : _this_eventsources_eventSourceName_config_log.attributes;
        for(const key in eventSrcAttrs){
            const value = eventSrcAttrs[key].replace(/"?<(.*?)%\s*(.*?)\s*%>"?/, '$2');
            if (typeof value === "string" && value.match(/^(?:body\?.\.?|body\.|query\?.\.?|query\.|params\?.\.?|params\.|headers\?.\.?|headers\.|user\?.\.?|user\.)/)) {
                // eslint-disable-next-line no-template-curly-in-string
                const obj = Function('event', 'filter', 'return eval(`event.data.${filter}`)')(event, value);
                attrs[key] = obj;
            } else {
                attrs[key] = value;
            }
        }
        // Now override common log.attributes/log_attributes with event level attributes
        const eventAttrs = ((_eventConfig_log = eventConfig.log) === null || _eventConfig_log === void 0 ? void 0 : _eventConfig_log.attributes) || eventConfig.log_attributes;
        if (!eventAttrs) {
            return attrs;
        }
        for(const key in eventAttrs){
            const value = eventAttrs[key].replace(/"?<(.*?)%\s*(.*?)\s*%>"?/, '$2');
            if (typeof value === "string" && value.match(/^(?:body\?.\.?|body\.|query\?.\.?|query\.|params\?.\.?|params\.|headers\?.\.?|headers\.|user\?.\.?|user\.)/)) {
                // eslint-disable-next-line no-template-curly-in-string
                const obj = Function('event', 'filter', 'return eval(`event.data.${filter}`)')(event, value);
                attrs[key] = obj;
            } else {
                attrs[key] = value;
            }
        }
        return attrs;
    }
    /**
   * 
   * @param event 
   * @returns Attributes common to all events, based on `log.attributes` spec in config
   */ getCommonAttrs(event) {
        var _this_config_log;
        const attrs = {};
        //Common log attributes
        const commonAttrs = ((_this_config_log = this.config.log) === null || _this_config_log === void 0 ? void 0 : _this_config_log.attributes) || this.config.log_attributes || [];
        for(const key in commonAttrs){
            const value = commonAttrs[key].replace(/"?<(.*?)%\s*(.*?)\s*%>"?/, '$2');
            if (typeof value === "string" && value.match(/^(?:body\?.\.?|body\.|query\?.\.?|query\.|params\?.\.?|params\.|headers\?.\.?|headers\.|user\?.\.?|user\.)/)) {
                // eslint-disable-next-line no-template-curly-in-string
                const obj = Function('event', 'filter', 'return eval(`event.data.${filter}`)')(event, value);
                attrs[key] = obj;
            } else {
                attrs[key] = value;
            }
        }
        return attrs;
    }
    constructor(params = {}, withoutEventSource = false){
        _define_property(this, "datasources", {});
        _define_property(this, "eventsources", {});
        _define_property(this, "withoutEventSource", false);
        _define_property(this, "plugins", {});
        _define_property(this, "workflows", {});
        _define_property(this, "nativeFunctions", {});
        _define_property(this, "events", {});
        _define_property(this, "definitions", {});
        _define_property(this, "config", {});
        _define_property(this, "mappings", {});
        _define_property(this, "isProd", true) //process.env.NODE_ENV === 'production';
        ;
        _define_property(this, "folderPaths", void 0);
        // config
        this.config = config;
        // let's assume we a re getting the current directory, where module is imported
        const currentDir = (0, _process.cwd)();
        // destruct GodspeedParams, if not supplied, assign the default value
        let { eventsFolderPath, workflowsFolderPath, definitionsFolderPath, configFolderPath, datasourcesFolderPath, eventsourcesFolderPath, mappingsFolderPath, pluginsFolderPath } = params;
        eventsFolderPath = (0, _path.join)(currentDir, this.isProd ? params.eventsFolderPath || '/dist/events' : params.eventsFolderPath || '/src/events');
        workflowsFolderPath = (0, _path.join)(currentDir, this.isProd ? params.workflowsFolderPath || '/dist/functions' : params.workflowsFolderPath || '/src/functions');
        definitionsFolderPath = (0, _path.join)(currentDir, this.isProd ? params.definitionsFolderPath || '/dist/definitions' : params.definitionsFolderPath || '/src/definitions');
        configFolderPath = (0, _path.join)(currentDir, this.isProd ? params.configFolderPath || '/config' : params.configFolderPath || '/config');
        datasourcesFolderPath = (0, _path.join)(currentDir, this.isProd ? params.datasourcesFolderPath || '/dist/datasources' : params.datasourcesFolderPath || '/src/datasources');
        eventsourcesFolderPath = (0, _path.join)(currentDir, this.isProd ? params.eventsourcesFolderPath || '/dist/eventsources' : params.eventsourcesFolderPath || '/src/eventsources');
        mappingsFolderPath = (0, _path.join)(currentDir, this.isProd ? params.mappingsFolderPath || '/dist/mappings' : params.mappingsFolderPath || '/src/mappings');
        pluginsFolderPath = (0, _path.join)(currentDir, this.isProd ? params.mappingsFolderPath || '/dist/plugins' : params.mappingsFolderPath || '/src/plugins');
        this.folderPaths = {
            events: eventsFolderPath,
            workflows: workflowsFolderPath,
            config: configFolderPath,
            definitions: definitionsFolderPath,
            datasources: datasourcesFolderPath,
            eventsources: eventsourcesFolderPath,
            mappings: mappingsFolderPath,
            plugins: pluginsFolderPath
        };
        this.withoutEventSource = withoutEventSource;
        Object.freeze(this.folderPaths);
    }
}
const _default = Godspeed;
