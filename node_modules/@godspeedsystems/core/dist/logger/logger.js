/*
* You are allowed to study this software for learning and local * development purposes only. Any other use without explicit permission by Mindgrep, is prohibited.
* Â© 2022 Mindgrep Technologies Pvt Ltd
*/ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "logger", {
    enumerable: true,
    get: function() {
        return logger;
    }
});
const _pino = /*#__PURE__*/ _interop_require_default(require("pino"));
const _config = /*#__PURE__*/ _interop_require_default(require("config"));
const _utils = require("../core/utils");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var _conf_log, _conf_log1, _conf_log2, _conf_log3;
const conf = _config.default;
const configRedact = conf.redact || ((_conf_log = conf.log) === null || _conf_log === void 0 ? void 0 : _conf_log.redact) || [];
let redactAttrs = [];
for (const redactAttr of configRedact){
    if (redactAttr.match(/^\*\*/)) {
        const fieldName = redactAttr.replace(/^\*\*\./, '');
        redactAttrs.push(`${fieldName}`, `*.${fieldName}`, `*.*.${fieldName}`, `*.*.*.${fieldName}`, `*.*.*.*.${fieldName}`, `*.*.*.*.*.${fieldName}`, `*.*.*.*.*.*.${fieldName}`, `*.*.*.*.*.*.*.${fieldName}`, `*.*.*.*.*.*.*.*.${fieldName}`, `*.*.*.*.*.*.*.*.*.${fieldName}`);
    } else {
        redactAttrs.push(redactAttr);
    }
}
let logTarget;
if (process.env.OTEL_ENABLED == 'true' && process.env.NODE_ENV != 'dev') {
    logTarget = "../pino/pino-opentelemetry-transport.js";
} else {
    logTarget = "pino-pretty";
}
let timestampSetting;
if ((_conf_log1 = conf.log) === null || _conf_log1 === void 0 ? void 0 : _conf_log1.timestamp) {
    timestampSetting = (0, _utils.getAtPath)(_pino.default, conf.log.timestamp);
}
let logger = (0, _pino.default)({
    level: ((_conf_log2 = conf.log) === null || _conf_log2 === void 0 ? void 0 : _conf_log2.level) || conf.log_level || 'info',
    //@ts-ignore
    timestamp: timestampSetting,
    formatters: {
        bindings: (bindings)=>{
            var _conf_log_bindings, _conf_log, _conf_log_bindings1, _conf_log1;
            if (!((_conf_log = conf.log) === null || _conf_log === void 0 ? void 0 : (_conf_log_bindings = _conf_log.bindings) === null || _conf_log_bindings === void 0 ? void 0 : _conf_log_bindings.pid)) {
                delete bindings.pid;
            }
            if (!((_conf_log1 = conf.log) === null || _conf_log1 === void 0 ? void 0 : (_conf_log_bindings1 = _conf_log1.bindings) === null || _conf_log_bindings1 === void 0 ? void 0 : _conf_log_bindings1.hostname)) {
                delete bindings.hostname;
            }
            return bindings;
        }
    },
    transport: {
        target: logTarget,
        options: {
            destination: 1,
            sync: (_conf_log3 = conf.log) === null || _conf_log3 === void 0 ? void 0 : _conf_log3.sync,
            Resource: {
                'service.name': process.env.OTEL_SERVICE_NAME || 'unknown_service:node',
                env: process.env.NODE_ENV
            },
            include: 'level,time,hostname,pid'
        }
    },
    redact: {
        paths: redactAttrs,
        censor: '*****'
    }
});
function loggerFn(logger) {
    [
        'info',
        'debug',
        'error',
        'fatal'
    ].forEach((val)=>{
        const method = logger[val];
        // const bound = method.bind(logger);
        logger[val] = function() {
            try {
                method.bind(logger)(...arguments);
            } catch (e) {
                console.log(`Pino: error executing ${val} {${e.message}}`);
                console.log(`Printing original error log arguments: %o`, ...arguments);
            }
        };
    });
    return logger;
}
logger = loggerFn(logger);
var childFn = logger.child.bind(logger);
logger.child = function(bindings, options) {
    return loggerFn(childFn(bindings, options));
};
