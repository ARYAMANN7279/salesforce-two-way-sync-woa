import { CHANNEL_TYPE, ACTOR_TYPE, EVENT_TYPE, PlainObject } from './common';
import pino from 'pino';
export declare class GSFunction extends Function {
    yaml: PlainObject;
    id: string;
    args?: any;
    args_script?: Function;
    fn?: Function;
    onError?: PlainObject;
    retry?: PlainObject;
    isSubWorkflow?: boolean;
    logs?: PlainObject;
    metrics?: [PlainObject];
    workflow_name?: string;
    workflows: PlainObject;
    nativeFunctions: PlainObject;
    fnScript?: Function;
    caching?: PlainObject;
    constructor(yaml: PlainObject, workflows: PlainObject, nativeFunctions: PlainObject, _fn?: Function, args?: any, isSubWorkflow?: boolean, fnScript?: Function, location?: PlainObject);
    _internalCall(ctx: GSContext, taskValue: any): Promise<GSStatus>;
    _observability(ctx: GSContext, taskValue: any): Promise<GSStatus>;
    _executefn(ctx: GSContext, taskValue: any): Promise<GSStatus>;
    handleError(ctx: GSContext, status: GSStatus, taskValue: any): Promise<GSStatus>;
    /**
     *
     * @param instruction
     * @param ctx
     */
    _call(ctx: GSContext, taskValue: any): Promise<GSStatus>;
}
export declare class GSSeriesFunction extends GSFunction {
    _call(ctx: GSContext, taskValue: any): Promise<GSStatus>;
}
export declare class GSDynamicFunction extends GSFunction {
    _call(ctx: GSContext, taskValue: any): Promise<GSStatus>;
}
export declare class GSParallelFunction extends GSFunction {
    _call(ctx: GSContext, taskValue: any): Promise<GSStatus>;
}
export declare class GSSwitchFunction extends GSFunction {
    condition_script?: Function;
    constructor(yaml: PlainObject, workflows: PlainObject, nativeFunctions: PlainObject, _fn?: Function, args?: any, isSubWorkflow?: boolean, location?: PlainObject);
    _call(ctx: GSContext, taskValue: any): Promise<GSStatus>;
}
export declare class GSIFFunction extends GSFunction {
    condition_script?: Function;
    task?: GSFunction;
    else_fn?: GSFunction;
    constructor(yaml: PlainObject, workflows: PlainObject, nativeFunctions: PlainObject, _fn?: Function, args?: any, isSubWorkflow?: boolean, location?: PlainObject);
    _call(ctx: GSContext, taskValue: any): Promise<GSStatus>;
}
export declare class GSEachParallelFunction extends GSFunction {
    value_script?: Function;
    constructor(yaml: PlainObject, workflows: PlainObject, nativeFunctions: PlainObject, _fn?: Function, args?: any, isSubWorkflow?: boolean, location?: PlainObject);
    _call(ctx: GSContext, taskValue: any): Promise<GSStatus>;
}
export declare class GSEachSeriesFunction extends GSFunction {
    value_script?: Function;
    constructor(yaml: PlainObject, workflows: PlainObject, nativeFunctions: PlainObject, _fn?: Function, args?: any, isSubWorkflow?: boolean, location?: PlainObject);
    _call(ctx: GSContext, taskValue: any): Promise<GSStatus>;
}
/**
 * Final outcome of GSFunction execution.
 */
export declare class GSStatus {
    success: boolean;
    code?: number;
    message?: string;
    data?: any;
    headers?: {
        [key: string]: any;
    };
    exitWithStatus?: boolean;
    constructor(success?: boolean, code?: number, message?: string, data?: any, headers?: {
        [key: string]: any;
    });
}
export declare class GSCloudEvent {
    id: string;
    time: Date;
    specversion: string;
    type: string;
    source: string;
    channel: CHANNEL_TYPE;
    actor: GSActor;
    data: PlainObject;
    metadata?: {
        telemetry?: object;
    };
    constructor(id: string, type: string, time: Date, source: string, specversion: string, data: object, channel: CHANNEL_TYPE, actor: GSActor, metadata: any);
    cloneWithNewData(data: PlainObject): GSCloudEvent;
}
/**
* Everything you need within a workflow, whether in native languages like JS/TS, or in yaml workflows and tasks.
 */
export declare class GSContext {
    inputs: GSCloudEvent;
    outputs: {
        [key: string]: GSStatus;
    };
    log_events: GSLogEvent[];
    config: PlainObject;
    datasources: PlainObject;
    mappings: PlainObject;
    functions: PlainObject;
    plugins: PlainObject;
    exitWithStatus?: GSStatus;
    logger: pino.Logger;
    childLogger: pino.Logger;
    forAuth?: boolean;
    constructor(config: PlainObject, datasources: PlainObject, event: GSCloudEvent, mappings: any, functions: PlainObject, plugins: PlainObject, logger: pino.Logger, childLogger: pino.Logger);
    cloneWithNewData(data: PlainObject): GSContext;
    addLogEvent(event: GSLogEvent): void;
}
/**
 *
 * Basic event information.this
 */
export declare class GSLogEvent {
    type: EVENT_TYPE;
    data: any;
    timestamp: Date;
    attributes: object;
    constructor(type: EVENT_TYPE, data: any, attributes?: object, timestamp?: Date);
}
export declare class GSActor {
    type: ACTOR_TYPE;
    tenant_id?: string;
    name?: string;
    id?: string;
    data?: PlainObject;
    constructor(type: ACTOR_TYPE, tenant_id?: string, name?: string, id?: string, data?: PlainObject);
}
/**
 *
 * Final ResponseStructure
 */
export interface GSResponse {
    apiVersion?: string;
    context?: string;
    id?: string;
    method?: string;
    data?: {
        kind?: string;
        fields?: string;
        etag?: string;
        id?: string;
        lang?: string;
        updated?: string;
        deleted?: boolean;
        currentItemCount?: number;
        itemsPerPage?: number;
        startIndex?: number;
        totalItems?: number;
        pageIndex?: number;
        totalPages?: number;
        pageLinkTemplate?: number;
        next?: PlainObject;
        nextLink?: string;
        previous?: PlainObject;
        previousLink?: string;
        self?: PlainObject;
        selfLink?: string;
        edit?: PlainObject;
        editLink?: string;
        items?: PlainObject[];
    };
    error?: {
        code?: number;
        message?: string;
        errors?: {
            domain?: string;
            reason?: string;
            message?: string;
            location?: string;
            locationType?: string;
            extendedHelp?: string;
            sendReport?: string;
        }[];
    };
}
