/*
* You are allowed to study this software for learning and local * development purposes only. Any other use without explicit permission by Mindgrep, is prohibited.
* Â© 2022 Mindgrep Technologies Pvt Ltd
*/ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return compileScript;
    }
});
const _config = /*#__PURE__*/ _interop_require_default(require("config"));
const _logger = require("../logger");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
//@ts-ignore
const mappings = global.mappings;
function substitute(value, location) {
    const initialStr = value;
    try {
        if (value.match(/<(.*?)%/)) {
            let script = value.replace(/"?<(.*?)%\s*(.*?)\s*%>"?/, '$2');
            //TODO: pass other context variables
            if (!(script.match(/<(.*?)%/) && script.match(/%>/))) {
                //@ts-ignore
                value = Function('config', 'mappings', 'return ' + script)(_config.default, global.mappings);
            }
        }
    } catch (ex) {
        if (initialStr.includes('inputs') || initialStr.includes('outputs')) {
            _logger.logger.info(location, 'Could not compile script containing `inputs` or `outputs` because they are available during runtime and not loadtime. if intended use of this script is during runtime you should ignore this message. Original script: %s. Compiled script %s. Error message %s', initialStr, value, ex.message);
        } else {
            _logger.logger.fatal(location, 'Caught exception in script compilation, script: %s compiled script %s. Error message %s\n error %o %o', initialStr, value, ex.message, ex, ex.stack);
            process.exit(1);
        }
    }
    return value;
}
function compileScript(args, location) {
    if (!args) {
        return args;
    }
    if (typeof args == 'object') {
        if (!Array.isArray(args)) {
            let out = {};
            for(let k in args){
                out[k] = compileScript(args[k], location);
            }
            return out;
        } else {
            let out = [];
            for(let k in args){
                out[k] = compileScript(args[k], location);
            }
            return out;
        }
    } else if (typeof args == 'string') {
        return substitute(args, location);
    }
    return args;
}
