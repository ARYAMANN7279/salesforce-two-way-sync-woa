/*
 * You are allowed to study this software for learning and local * development purposes only. Any other use without explicit permission by Mindgrep, is prohibited.
 * Â© 2022 Mindgrep Technologies Pvt Ltd
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return loadEvents;
    }
});
const _utils = require("./utils");
const _yamlLoader = /*#__PURE__*/ _interop_require_default(require("./yamlLoader"));
const _jsonSchemaValidation = require("./jsonSchemaValidation");
const _expandVariables = /*#__PURE__*/ _interop_require_default(require("./expandVariables"));
const _logger = require("../logger");
const _functionLoader = require("./functionLoader");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const rewiteRefsToAbsolutePath = (events)=>{
    if (!Object.keys(events).length) {
        // there are no events
        return;
    }
    // deep copy
    _logger.logger.debug('Replacing $refs in events with definitions.');
    const deepCopyOfEvents = JSON.parse(JSON.stringify(events));
    return Object.keys(deepCopyOfEvents).reduce((accumulator, eventKey)=>{
        var _eventObject_body, _eventObject_data_body, _eventObject_data, _eventObject_data_schema, _eventObject_data1;
        let eventObject = deepCopyOfEvents[eventKey];
        // logger.debug('eventObject %o', eventObject);
        const bodyContent = (eventObject === null || eventObject === void 0 ? void 0 : (_eventObject_body = eventObject.body) === null || _eventObject_body === void 0 ? void 0 : _eventObject_body.content) || (eventObject === null || eventObject === void 0 ? void 0 : (_eventObject_data = eventObject.data) === null || _eventObject_data === void 0 ? void 0 : (_eventObject_data_body = _eventObject_data.body) === null || _eventObject_data_body === void 0 ? void 0 : _eventObject_data_body.content);
        if (bodyContent) {
            Object.keys(bodyContent).forEach((contentType)=>{
                let contentSchema = bodyContent[contentType].schema;
                if (contentSchema) {
                    if (contentSchema.hasOwnProperty('$ref')) {
                        const defKey = contentSchema.$ref;
                        contentSchema.$ref = 'https://godspeed.systems/definitions.json' + defKey;
                        bodyContent[contentType].schema = contentSchema;
                    }
                }
            });
        }
        const responses = (eventObject === null || eventObject === void 0 ? void 0 : eventObject.responses) || (eventObject === null || eventObject === void 0 ? void 0 : (_eventObject_data1 = eventObject.data) === null || _eventObject_data1 === void 0 ? void 0 : (_eventObject_data_schema = _eventObject_data1.schema) === null || _eventObject_data_schema === void 0 ? void 0 : _eventObject_data_schema.responses);
        // logger.debug('responses %o', responses);
        if (responses) {
            Object.keys(responses).forEach((responseCode)=>{
                let responseContent = responses[responseCode].content;
                // logger.debug('responseContent %o', responseContent);
                if (responseContent) {
                    Object.keys(responseContent).forEach((responseContentType)=>{
                        let responseContentTypeSchema = responseContent[responseContentType].schema;
                        if (responseContentTypeSchema) {
                            if (responseContentTypeSchema.hasOwnProperty('$ref')) {
                                const defKey = responseContentTypeSchema.$ref;
                                responseContentTypeSchema.$ref = 'https://godspeed.systems/definitions.json' + defKey;
                                responses[responseCode].content[responseContentType].schema = responseContentTypeSchema;
                            }
                        }
                    });
                }
            });
        }
        accumulator[eventKey] = eventObject;
        return accumulator;
    }, {});
};
function loadEvents(allFunctions, nativeFunctions, eventsFolderPath, eventSources) {
    return _loadEvents.apply(this, arguments);
}
function _loadEvents() {
    _loadEvents = _async_to_generator(function*(allFunctions, nativeFunctions, eventsFolderPath, eventSources) {
        const events = yield (0, _yamlLoader.default)(eventsFolderPath, true);
        if (events && !Object.keys(events).length) {
            _logger.logger.error(`There are no events defined in events dir: ${eventsFolderPath}. Exiting.`);
            process.exit(1);
        }
        // logger.debug('event configs %o', events);
        const location = {
            location: "Events loading"
        };
        const evalEvents = (0, _expandVariables.default)(rewiteRefsToAbsolutePath(events), location);
        const checkFn = (0, _utils.checkFunctionExists)(events, allFunctions);
        if (!checkFn.success) {
            _logger.logger.fatal(`Error in loading functions for events. Error message: %s. Exiting. ${checkFn.message}`);
            process.exit(1);
        }
        if (evalEvents) {
            yield (0, _jsonSchemaValidation.loadJsonSchemaForEvents)(evalEvents);
        }
        splitEventsByEventSources(evalEvents);
        loadEventWorkflows(evalEvents, eventSources, allFunctions, nativeFunctions);
        return evalEvents;
    });
    return _loadEvents.apply(this, arguments);
}
function splitEventsByEventSources(events) {
    Object.keys(events).forEach((key)=>{
        const eventSourceName = key.split('.')[0];
        if (!eventSourceName.includes('&')) {
            return;
        }
        const eventSources = eventSourceName.split('&');
        const commonKeyPart = key.replace(eventSourceName, '');
        for (let eventSource of eventSources){
            eventSource = eventSource.trim();
            const newKey = eventSource + commonKeyPart;
            events[newKey] = JSON.parse(JSON.stringify(events[key]));
        }
        delete events[key];
    });
}
/**
    * Iterate through all event definitions and 
    * load the authz, on_request_validation_error, on_response_validation_error and any such workflows
  */ const FUNCTIONS_TO_LOAD = [
    'authz',
    'on_request_validation_error',
    'on_response_validation_error'
];
function loadEventWorkflows(events, eventSources, allFunctions, nativeFunctions) {
    Object.keys(events).forEach((key)=>{
        const eventConfig = events[key];
        const eventSourceName = key.split('.')[0];
        const eventSource = eventSources[eventSourceName];
        if (!eventSource) {
            _logger.logger.error(`No event source found for the event uri ${eventSourceName}`);
            process.exit(1);
        }
        FUNCTIONS_TO_LOAD.forEach((functionType)=>{
            if (eventConfig[functionType] === 'false') {
                delete eventConfig[functionType];
                //remove function for this functionType if event config explicity says false
                //ex. authz: false or on_request_validation_error: false
                //If authz is undefined null or 0 it will not override default config
                //because of zero trust policy.
                // functionConfig = null;
                return;
            }
            let functionConfig;
            if (eventConfig[functionType]) {
                //for a non-falsy value, lets use this instead of the default config from event source
                functionConfig = eventConfig[functionType];
            } else if (eventSource.config[functionType]) {
                //default value from event source
                functionConfig = eventSource.config[functionType];
            } else {
                return;
            }
            let _function; //The loaded function
            if (typeof functionConfig === 'string') {
                //Is expected to be a valid function/workflow path
                //For ex. authz: "com.biz.common_authz"
                _function = allFunctions[functionConfig];
            } else if (typeof functionConfig === 'object') {
                //Is expected to be a `WorkflowJSON` declared within a yaml eventsource/event config
                const taskLocation = {
                    eventSourceType: eventConfig.type,
                    eventKey: key,
                    fn: functionType
                };
                _function = (0, _functionLoader.createGSFunction)(functionConfig, allFunctions, nativeFunctions, null, taskLocation);
            }
            if (_function) {
                eventConfig[functionType] = _function;
            } else {
                _logger.logger.error(`Could not find any valid function definition for %o when loading ${functionType} for event ${key}`, functionConfig);
                process.exit(1);
            }
        });
    });
}
